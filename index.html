<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - blender -json</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#777;
				padding:0;
				margin:0;
				overflow:hidden;
			}

			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>

		<script src="js/three.js"></script>
		<script src="js/orbit-controls.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/dat.gui.js"></script>

		
		  <script id="skyboxVS" type="x-shader/x-vertex">

	uniform mat4 modelMatrix;
	uniform mat4 viewMatrix;
      	uniform mat4 projectionMatrix;

     	attribute vec3 position; 

	varying vec3 vWorldPosition;
	
	void main() {

		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
		vWorldPosition = worldPosition.xyz;

		vec4 p = viewMatrix * modelMatrix * vec4(position, 1.0);
		gl_Position = projectionMatrix * p;
		
     	 }

    </script>


    <script id="skyboxFS" type="x-shader/x-fragment">

		precision mediump float;
		
		uniform samplerCube tCube;
		varying vec3 vWorldPosition;

		void main() {

			gl_FragColor = textureCube( tCube, vec3(  vWorldPosition ) );
		}
	
    </script>


  <script id="vertexShader" type="x-shader/x-vertex">

	uniform mat3 normalMatrix;
	uniform mat4 modelMatrix;
	uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
	uniform vec3 cameraPosition;

	attribute vec4 vertex;
	attribute vec3 normal;
    attribute vec3 position; 
    attribute vec2 uv;

	varying vec3 worldNormal;
	varying vec3 incident;
	varying vec2 vUV;
	
	void main() {


		vUV = uv; 
		vec4 worldPosition = modelMatrix * vec4( position, 1.0 ); // world position
		worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal ); // world space normal
		incident = worldPosition.xyz - cameraPosition.xyz;
		
        vec4 mvPosition = viewMatrix * modelMatrix * vec4(position, 1.0); // model view position
		
		
		/*
		vRefraction = refract(incidentNormal,worldNormal,(rAir/rGlass));
		vReflection = reflect(incidentNormal,worldNormal);
		// Schlick's approximation of fresnel
		//vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower);

		vFresnel = rIndex + (1.0 - rIndex) * pow((1.0-dot(-incidentNormal,worldNormal)),5.0);
		*/
		
        gl_Position = projectionMatrix * mvPosition; 
    }

    </script>


    <script id="fragmentShader" type="x-shader/x-fragment">

	precision mediump float;
	uniform samplerCube tCube;
	uniform float index1;
	uniform float index2;
	uniform float fresPower;
	uniform float fresBias;
	
	varying vec2 vUV;
	varying vec3 worldNormal;
	varying vec3 incident;


	// Schlick's approximation of fresnel
	// fresnelAngle = index + (1-cos(fresnelAngle))^5 * (1-index)
		float fresnelApprox(vec3 incident, vec3 normal)
		{
			float bias = ((index1 - index2)*(index1-index2))/((index1 + index2)*(index1+index2));
			float power = fresPower;
			float scale = 1.0 - bias;
			
			return bias + pow(1.0-dot(incident,normal),power)*scale; 
		}
	
	
	
      	void main() {
		//normalize vectors
		vec3 normal = normalize(worldNormal);
		vec3 incidentN = normalize(incident);
		
		// find reflection
		vec3 reflectV = normalize(reflect(incidentN,normal));
		vec3 reflectColor = textureCube(tCube,reflectV).xyz;
		// find refraction
		vec3 refractColor;
		refractColor.x = textureCube(tCube, refract(incidentN, normal, index2)).x;
		refractColor.y = textureCube(tCube, refract(incidentN, normal, index2-0.02)).y;
		refractColor.z = textureCube(tCube, refract(incidentN, normal, index2-0.04)).z;

		float fresnelEffect = fresnelApprox(-incidentN, normal);
		
        gl_FragColor = vec4(mix(refractColor, reflectColor, fresnelEffect),1.0);//c1; //, c2, 0.5);
	}

	</script>


	<script>

		// Load shaders
		var vs = document.getElementById( 'vertexShader' ).textContent;
      	var fs = document.getElementById( 'fragmentShader' ).textContent;

		// Declare variables
		var container;
		var camera, scene, renderer; // Camera scene
		var controls; // Camera controller

		// Skybox
		var skyMesh, cubeMap;
		
		// Load meshes and textures
		var mesh;
		var glassMesh;
		var texture1;

		// GUI
		var gui = new dat.GUI( { width: 350 } );
		// 
		init();
		animate();

		// Initialize function
		function init() {

			// Initialize scene
			container = document.getElementById( 'container' );

			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );
			camera.position.set( 0, 0, 5 );
			
			controls = new THREE.OrbitControls( camera );
			controls.update();

			scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2( 0x000000, 0.035 );

			options = {
				index1: 1.0, // Index of air (vacuum)
				index2: 1.51714, // Index of glass
				fresBias: 0.15,
				fresPower: 2.0,
				};
			
			// -- Skybox
			//	Skybox Shaders
			var sb_vs = document.getElementById( 'skyboxVS' ).textContent;
			var sb_fs = document.getElementById( 'skyboxFS' ).textContent;
			
			// Geometry
			var geometry_sb = new THREE.BoxGeometry(2000,2000,2000);
			
			cubeMap = new THREE.CubeTextureLoader()
				.setPath("./cubemap/")
				.load( [
			'posx.jpg',
			'negx.jpg',
			'posy.jpg',
			'negy.jpg',
			'posz.jpg',
			'negz.jpg'
				] );
			
			// Uniform
			var uniforms_sb = {"tCube": {type:"t",value:cubeMap}};
			
			// Material
			var material_sb = new THREE.RawShaderMaterial({
					uniforms:uniforms_sb,
					vertexShader:sb_vs,
					fragmentShader:sb_fs
				});
				
			material_sb.depthWrite = false;
			material_sb.side = THREE.BackSide;
			
			// Mesh
			skyMesh = new THREE.Mesh(geometry_sb,material_sb);
			scene.add(skyMesh);
			
			// Glass 
			//texture1 = new THREE.TextureLoader().load( 'angus.jpg' );
			//texture1 = createDataTexture();
			
			/*
			var uniforms = {
				tCube: {type: "t", value: cubeMap},
				index1: {type:"f", value:options.index1},
				index2: {type:"f",value:options.index2},
				fresBias: {type:"f",value:options.fresBias},
				fresPower: {type:"f",value:options.fresPower},
			}
			var geometry = new THREE.SphereGeometry(0.31,32,32)
			var material = new THREE.RawShaderMaterial({
					uniforms: uniforms,
					vertexShader: vs,
					fragmentShader: fs,
					});
			
			//var material = new THREE.MeshStandardMaterial({color:0x2194ce});
			mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);
			*/
			
			// Object Loading
			var loader = new THREE.JSONLoader();
			loader.load( 'json/glass.json', processBlenderObject );

			// Setup renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			window.addEventListener( 'resize', onWindowResize, false );
		}


		// Process cup
		function processBlenderObject (geometry,materials) {
				console.log(geometry);
				console.log(materials);
				//var useGeometry = new THREE.BufferGeometry().fromGeometry( geometry );
				var useGeometry = geometry;

				var uniforms = {
					index1: {type:"f", value:options.index1},
					index2: {type:"f",value:options.index2},
					
					tCube: {type: "t", value: cubeMap},
					t1: { type: "t", value: texture1  },
					fresPower: {type:"f",value:options.fresPower},
				};

				var material = new THREE.RawShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vs,
					fragmentShader: fs,	
				} );

				glassMesh = new THREE.Mesh( useGeometry, material );
				gui.add( options, "index1", 1,5).onChange(function(value){
					glassMesh.material.uniforms.index1.value = value;
				});
				gui.add( options, "index2", 1,5).onChange(function(value){
					glassMesh.material.uniforms.index2.value = value;
				});
				gui.add( options, "fresPower", 1,5).onChange(function(value){
					glassMesh.material.uniforms.index2.value = value;
				});


				//positioning and scaling blender obj so that it's in the center of the screen
				glassMesh.position.set( 0, -1.5, 0 );
				glassMesh.scale.set(0.012,0.012,0.012);
 
				scene.add( glassMesh );

		}
		
		// Process lid
		function processLidObject(geometry,materials){
		//var useGeometry = new THREE.BufferGeometry().fromGeometry( geometry );
				var useGeometry = geometry;

				var uniforms = {
					t1: { type: "t", value: texture1  },
				};

				var material = new THREE.RawShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vs,
					fragmentShader: fs,	
				} );


				mesh = new THREE.Mesh( useGeometry, material );

				mesh.position.set( 0, -1.5, 0 );
				//positioning and scaling blender obj so that it's in the center of the screen

				scene.add( mesh );


		}
		


		// Resize the renderer on window change
		function onWindowResize( event ) {

			renderer.setSize( window.innerWidth, window.innerHeight );

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
		}


		// Animate, calls Render()
		function animate() {

			requestAnimationFrame( animate );
			render();
		}

		function render() {
			camera.lookAt( scene.position );
			renderer.render( scene, camera );
		}

		// Creates textures dynamically
		function createDataTexture() {

			// create a buffer with color data

			var resX = 25;
			var resY = 25;

			var size = resX * resY;
			var data = new Uint8Array( 4 * size );

			for ( var i = 0; i < size; i++ ) {	
				var stride = i * 4;

				data[ stride ] = Math.random() * 255;
				data[ stride + 1 ] = Math.random() * 255;;
				data[ stride + 2 ] = Math.random() * 255;;
				data[ stride + 3 ] = 255;
			}


			var texture = new THREE.DataTexture( data, resX, resY, THREE.RGBAFormat );
			texture.needsUpdate = true; // just a weird thing that Three.js wants you to do after you set the data for the texture

			return texture;
		}


	</script>
	</body>
</html>

